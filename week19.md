# ARTS Week 
>[![DoUaXq.jpg](https://s3.ax1x.com/2020/12/02/DoUaXq.jpg)](https://imgchr.com/i/DoUaXq)
>> todo

***
## Algoithm
>[首个共同的祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci)

### 概述
设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

    例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
    
        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4
    示例 1:
    
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    输出: 3
    解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
    示例 2:
    
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    输出: 5
    解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
    说明:
    
    所有节点的值都是唯一的。
    p、q 为不同节点且均存在于给定的二叉树中。

### 思考
1. 每一个节点都是唯一
2. p&q 一定都在树中

分成三种情况：
1. p/q 分别在左右子树中，那么最近的节点就是 root节点
2. p&q 都在同一子树中，那么就返回其子树的 root节点
3. p/q 其中一个为最近的节点，那么直接返回其节点

然后依次进行遍历
***

### coding

```python

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    """
    1. 题目中说明 节点都是 唯一
    2. p & q 都在树中

    按照不同情况区分：
    1. p/q 在root的左右子树中
    2. p&q 在root的同一个子树中
    3. p/q 为其中一个跟节点

    依次按照这种情况进行递归查询

    """
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        if not root or root == p or root == q:
            return root

        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left:
            return right

        if not right:
            return left

        if left and right:
            return root

```

### 总结
1. 树的问题大部分都可以通过递归来进行解决

递归的方法论：
1. 终止条件：
    1. not root
    2. left==right 
    3. root==p
2. 递归问题：
    1. 将问题进行分解，分成不同的情况进行沟通处理。
3. 递归顺序：
    1. 前序
    2. 中序
    3. 后序

## Review
>[todo]()

### 概述
todo 


***
## Tip
>[架构老化与重构](https://time.geekbang.org/column/article/180396)

### 概述
1. 如何重构代码
    1. 尽可能避免核心代码修改
    2. 新业务独立，避免核心代码侵入
2. 其他方面
    1. 实际上从难度来说，重构比一个全新业务的架构过程要难得多。
    2. 重构，不只是一个架构的合理性问题。它包含了架构合理性的考量，因为我们需要知道未来在哪里，我们迭代方向在哪里。
    3. 但重构的挑战远不只是这些。这是一个集架构设计（未来架构应该是什么样的）、资源规划与调度（与新功能开发的优先级怎么排）、阶段规划（如何把大任务变小，降低内部的抵触情绪和项目风险）以及持久战的韧性与毅力的庞大工程。

### 引用 leslie 

引用老师课程中关于重构的一句经典话语"架构设计（未来架构应该是什么样的）、资源规划与调度（与新功能开发的优先级怎么排）、阶段规划（如何把大任务变小，降低内部的抵触情绪和项目风险）以及持久战的韧性与毅力的庞大工程。”体现了老师一直强调的架构与业务的理解。
软件架构的老化与重构参与不多：不过数据库架构这块的事情经历过不少。虽范围有所缩小，不过核心思路大致相同。对于老师的这个总结拆分简析一下；
#### 架构设计
1. 需要梳理出当前的现状，对于整体现状做出分析；目的是再烂的架构都有其合理性，其中那些可能会被将来做为最小原子使用这是需要做的；
2. 针对分析的结果再权衡利弊的基础上想出改进方案，毕竟重构升级的过程还是有许多关联性的数据；
3. 未来的短、中、长期规划大致是怎样，怎样才能可扩展或后期升级。
#### 资源规划与调度
1. 资源规划：要做的就是拆分，需要对于团队/项目有足够的了解才能更好的明白和了解有什么样资源以及可以用到什么样的程度
2. 资源调度：任何一个项目会有固定资源和非固定/调用资源，固定和非固定的使用程度和时间完全不同的且了解不同，这个协调能力是一个项目经理所需的能力。
#### 阶段规划以及持久性
1. 格局观和可持续性，即通常所说的CI/CD特性；对于整体的了解越明白、格局观与弹性越好，规划和持续性就越好。
2. 其实还涉及到产品中常用的MVP特性，试错中找到最佳持续方案。


以上是我对于老师今天分享的思考和理解以及梳理；一路学习、一路实践、一路反思、一路收获。感谢老师的付出，让我在学习中能不断收获到不一样的知识；期待老师的后续分享，谢谢。


***
## Share
>[todo]()

### 概述
todo  